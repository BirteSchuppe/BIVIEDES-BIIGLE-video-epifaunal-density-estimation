---
title: "step 2: smoothing navigation data"
author: "Your Name"
date: "Today's Date"
format:
  html:
    toc: true
    number-sections: true
editor: 
  markdown: 
    wrap: sentence
---

## Setup

Before beginning, we will load necessary libraries.

```{r}


library(lubridate)
library(tsibble)
library(zoo) # for interpolations
library(plotly) # for interactive plots 
library(tidyverse)
library(magrittr)

getwd() -> wd
# delete the "code" part of the pathway so that the rest of the path are not relative to the code directory
wd <- str_remove(wd, "/code") 

# set the working directory to the directory above "code"
setwd(wd)

# list the csv tables and print their names
list.files(paste0( wd,"/nav"), pattern = ".csv$" ) %>% 
# exclude the "arranged" pattern 
str_subset("smoothed", negate = T)  %>%  paste0("\n avialable CSV tables: \n",.) %>% cat

```

# Load data

open the table with time and xy positions, here maybe need to change/delete working direction???
(linked to my local drive) setwd("D:/PHD/ROV/ROV raw video density estimates/navigation_smoothing")

```{r}

navigation_file <- "nav_horsvaagen1_bin1.csv"
read_csv(paste0(wd,"/nav/",navigation_file) ) -> navigation

```

# set the time column

depending on the formate of your time column and The mood of Excel, you might need to change the time column to a datetime object if it is not done automatically

```{r}

 # fill the gaps in the shp file
# time management
navigation %>% 
# make the time column - if you have a data and a time column
  mutate(datetime = datetime) -> maskxy
# if you have a dmy_hms character string


# check that datetime is a datetime object
# if class of datetime is not "POSIXct" or "POSIXt" then convert it
if(!class(maskxy$datetime)[1] %in% c("POSIXct", "POSIXt"))  {
  print("setting datetime to POSIXt")
  maskxy %>%  mutate( datetime = dmy_hms(datetime)) -> maskxy
}

# check that the time column is in the right format
maskxy %>% 
  select(datetime) %>% glimpse

# make a time column of elapsed seconds based on column datetime, in case for if videotime (logged via ROV system) is not starting at 0
maskxy$elapsed_seconds <- as.numeric(difftime(maskxy$datetime, maskxy$datetime[1],units = "secs"))
```

# interpolate

The zoo::na.approx function is part of the zoo package in R, which is designed for handling time series data and other ordered observations. The na.approx function is specifically used to approximate or interpolate missing values (NAs) in a numeric vector or time series. It assumes a linear relationship between the known data points surrounding the missing values to estimate them.

```{r}

# create the missing time stamps so that you have a reading at each second 
maskxy %>%
  select(datetime, videotime,lon,lat, depth, elapsed_seconds ) %>% 
  add_row(. , datetime  = .$datetime[1] + 1  , .before = 2) %>% 
  as_tsibble(index = datetime) %>%
  fill_gaps() %>% # automatically creates the missing timestamps
  as_tibble() %>%
  # interpolate the coordinates values for the timestamps you have created
  # these wont be accurate but you will replace them soon
  # they are still a basic interpolation of the closest coordinates 
  mutate(LON2 = zoo::na.approx(as.vector(lon)),
         LAT2 = zoo::na.approx(as.vector(lat)), 
         DEPTH2 = zoo::na.approx(as.vector(depth)),
         VIDEOTIME2 = zoo::na.approx(as.vector(elapsed_seconds))           ) -> maskxy  
# note this might also be enough if your track look good

# check that there are no NA left in LON2 or LAT2 or DEPTH2
if(any(is.na(maskxy$LON2)) | any(is.na(maskxy$LAT2)) | any(is.na(maskxy$DEPTH2))) {
  print("There are NA values in LON2, LAT2 or DEPTH2")
} else {
  print("No NA values in LON2, LAT2 or DEPTH2. That's great")
}
 

```


# Smooth

*stats::smooth.spline* function specifically fits a cubic smoothing spline, which finds a trade-off between fitting the data closely and maintaining smoothness.

Key Parameters

-   t: A numeric vector specifying the predictor variable.
    Here, we use t as a sequence from 1 to the number of time stamps in the data.

-   y: A numeric vector specifying the response variable.
    The lat and long

-   spar: A numeric value that controls the smoothness of the spline.
    A smaller value of spar results in a smoother spline, while a larger value allows the spline to fit the data more closely.
    if too high, all the turns in your data will be smoothed out.
    If too low, the spline will not remove the noise in positioning and the distance traveled will be overestimated.

-   w: Optional weights for the observations.

-   df: Degrees of freedom for the spline.
    This can be used instead of spar to control the smoothness.

-   cv: If TRUE, the smoothing parameter is chosen by cross-validation.

-   all.knots: If TRUE, all data points are used as knots.
    Otherwise, a subset of knots is chosen.

important smoothing parameters to set here:

```{r}


# Smooth the track  
t <- 1:nrow(maskxy)
x <- maskxy$LON2
y <- maskxy$LAT2
# z  # no smoothing of th ~DEPTH: interpolation should be enough 
# Fit a cubic smoothing spline to each dimension
# !!! this is user input. You can decide on the right smoothing parameter after checking the plot below
dfs = 50
spars = 0.8

sx <- smooth.spline(t, x, df = dfs, spar = spars, cv = TRUE)
sy <- smooth.spline(t, y, df = dfs, spar = spars, cv = TRUE)
 

```

# view raw and smooth nav

### plot in 2D

```{r}
# plot the recorded tracks 
plot(x,y, cex = 0.25, col = "black", main = paste0("Difference of un-smoothed and smoothed ROV transect "))
# overlay the smoothed track
lines(sx[[2]], sy[[2]], col = 2, lwd = 2)
legend("topleft", legend=c("smoothed", "un-smoothed"),
       col=c("red", "black"), lty=1:2, cex=0.8)

```

### interactive plot

# make the same plot with plotly to that you can zoom in or out. Use it to chekc the smoothing (orange line vs blue dots) and adjust the smoothing paramters in the box above

```{r}
# make the same plot in plotly
plot_ly() %>%
  add_trace(x = x, y = y, mode = "markers", type = "scatter", name = "un-smoothed", marker = list(size = 4)) %>%
  add_trace(x = sx[[2]], y = sy[[2]], mode = "lines", type = "scatter", name = "smoothed") %>%
  layout(title = "Difference of un-smoothed and smoothed ROV transect",
         xaxis = list(title = "Longitude"),
         yaxis = list(title = "Latitude"))
```

# add the depth to the plot and view in 3D

```{r}

# make the same plot in 3d with depth2 as the 3rd dimension
plot_ly() %>%
  # make smaller point size
  add_trace(x = x, y = y, z = - maskxy$DEPTH2, mode = "markers", type = "scatter3d", name = "un-smoothed", marker = list(size = 4)) %>%
  add_trace(x = sx[[2]], y = sy[[2]], z = - maskxy$DEPTH2, mode = "lines", type = "scatter3d", name = "smoothed") %>%
  layout(title = "Difference of un-smoothed and smoothed ROV transect",
         scene = list(xaxis = list(title = "Longitude"),
                      yaxis = list(title = "Latitude"),
                      zaxis = list(title = "Depth")))

```

# export

attach the smoothed XY and the interpolated depth to the navigation

```{r}
# add the new coordinates to the table
tibble( xsmoothed = sx[[2]] ,ysmoothed = sy[[2]] )  %>%
  bind_cols(maskxy,.) %>% 
  rename(depth_interpolated = DEPTH2, videotime_interpolated = VIDEOTIME2 ) -> smoothed_navigation

write_csv( smoothed_navigation, paste0(wd,"/nav/smoothed_",navigation_file))   
```
